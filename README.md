# 《大话设计模式》中的示例代码和各模式练习题 

以Test结尾的package为改设计模式练习题，题目在test.java中----练习题来源https://blog.csdn.net/qq_33220449/

AbstractFactory---**抽象工厂模式**：eg：使用不同数据库的数据访问，使用了反射+配置文件的方式实现切换数据库而不需要改动代码

Adapter---**适配器模式**：为了解决接口不兼容的问题，eg：Taget为用户所期待使用的接口；Adaptee为本来有的接口（需要进行适配的类）;Adapter为适配后的类;基本思想是将原来的类进行组合，而不需要对它们进行修改，来应对特定的使用目的

Builder---**建造者模式**：为了将一个对象的部件构造顺序和它具体各部件的实现分离开，从而达到降耦合、易扩展的目的;eg:Poduct类为最终所需要的被建造的产品;Builder接口及子类为对象各部件的实现;Director类功能是指定对象的部件构造顺序

CARP---**合成/聚合复用原则**（里面有**桥接模式**的代码）eg:一个手机里有很多的软件，每个软件又都能安装在不同品牌的手机上，这时候就应该有'手机品牌''手机软件'两个抽象类，并且手机品牌包含手机软件，它们两个是聚合关系。HandsetSoft+子类为手机的软件，HandBrand+子类为手机的品牌

**桥接模式的思想**：过度使用继承会导致类结构过于复杂，如果继承体系中有两个以上方向的变化，就应该将继承关系改为组合关系，从而使这两部分应对各自的变化。这也是合成-复用原则的体现。让抽象与实现可以各自变化。

ChainResponse---**职责链模式**：使多个用户都能处理到请求。eg:请假、加薪操作需要让经理、总监、总经理逐个审批。注意Handler类要设置下一级处理者。

Command---**命令模式**:将请求封装成对象，从而可用不同的请求对客户参数化；对请求排队或者记录请求日志。eg:Receiver类为请求的执行者;Command命令类让receiver执行请求（可以在执行前后进行加工）;Invoker类要求命令类执行请求。
命令模式是将调用操作的对象和知道如何实现操作的对象解耦。意味着发送者发送完请求就完事了，具体怎么做与发送请求者无关，这样就可以进行额外的操作，例如可以在不同的时刻指定、排列和执行请求，记录日志，支持事务、批处理。

Composite---**组合模式**:使对象可以形成树形结构以表示'部分-整体'的层次，使得用户对每个对象的使用都是一样的。eg:一个公司有总公司和多个分公司，这些部分均有HR部门和财务部门，使用组合模式可以让它们形成树形结构，从结构上对代码进行复用。

decorator---**装饰模式**:动态的给对象添加职责。如果子类只是为对象添加某个职责时，适合装饰模式，可以避免大量继承子类带来的类爆炸。eg:一个人穿衣服的搭配可以是多样的，比较适合用装饰模式而不适合增加子类的方式。Person为需要装饰的人; Finarty可以理解为给person穿衣服的人，其余的poqiuxie、kuaku、Tshirt可以分别理解为仅穿着破球鞋的人、仅穿着垮裤的人、仅穿着T恤的人，最后客户端调用实现类似迭代或套娃的方式对Person进行装扮。

Facade---**外观模式**:相当于对一个系统定义一个向外开发的接口，避免客户端之间与系统交互。可以理解为是一个大粒度的适配器，只不过适配器是适配对象，外观是适配系统。

Flyweight---**享元模式**:与组合模式目的相似，为了实现代码的复用，举个例子比如github网站，肯定不会是给每个用户都单独做一个网站、单独用一份数据库，而是通过共享模板数据库、使用ID区分的方式。eg:注意WebFactory中是使用了HashMap对需要共享的内容进行储存，共享的WebSite仅仅是通过User的不同来区分的。

IFactory---**工厂方法模式**:eg:计算器

Iterator---**迭代器模式**:各语言已经对迭代器模式进行了封装，可以直接使用。

mediator---**中介者模式**:各个对象的交互都集中到中介者对象进行，各个对象对其它对象的请求通过调用中介者的方法发出。弊端是中介者需要知道所有的对象。eg:USA和Iraq的通信由联合国发出。

Memento---**备忘录模式**:备忘录用来存储发起人的状态，管理者储存这个备忘录，客户端调用时不必知道发起人的状态细节。eg:GameRole游戏角色为发起人，RoleStateMemento为备忘录，RoleStateCaretaker为管理者。

Observer---**观察者模式（发布-订阅模式）**:一种一对多的依赖关系，多个观察者对象监听一个主题对象(通知者)，主题对象状态改变时会通知所有的观察者对象。eg:Subject及子类为通知者，它收集所有的观察者对象;Observer及子类为观察者，它提供一个update方法供通知者调用。

Prototype---**原型模式**:Java提供了Cloneable接口以供复制，使用时注意，Cloneable调用super.clone()方法是浅复制，引用类型元素仅复制引用，如果有链表需要单独对链表循环复制。

Proxy---**代理模式**:代理类和原类实现同一个接口，使用时代理类调用原类的方法执行，达到隐藏一个对象的目的。

simplefactory---**简单工厂模式**:不符合开放封闭原则，改良后有工厂方法模式和抽象工厂模式

Singleton--**单例模式**:分为懒汉式和饿汉式。饿汉式在声明时就创建对象，不存在线程不安全问题。

State---**状态模式**:有点类似职责链模式，职责链模式是传递请求，状态模式是在内部进行的不同状态下的类型切换。eg:State及子类为具体的状态，被Context维护持有，能进行当前状态的处理，读取Context的触发条件来判断是进行当前状态的处理还是调用Context切换状态;Context类维护一个当前状态,调用维护的具体状态的方法处理请求。客户端不需要有具体的状态对象，只需要实例一个Context类，设置Context的初始状态和触发状态切换的条件的变量。

strategy---**策略模式**:将算法的具体实现延迟到子类，Context维护具体的策略，调用策略的具体方法。客户端只需要实例Context对象传入具体的策略，策略可以很容易的更改。

TemplateMethod---**模板方法模式**:抽象模板类给出逻辑框架，具体的实现延迟到子类实现。个人理解:很像策略模式，只是在抽象类中把逻辑固定好，逻辑的组成延迟到子类实现。有些微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中，这些重复提取出来就成为了模板方法模式。

Visitor---**访问者模式**:仅适用于数据结构稳定的系统，例如人只分为男人和女人。在实际开发中使用较少，没看懂这个模式。

Zpractice---与设计模式无关，学习类加载和创建机制的验证代码，和编译期常量和运行时常量的验证代码。

### 状态模式与职责链模式对比：

它们都能解耦和优化大量的逻辑判断。

状态模式需要具体的状态子类指明它的下一个状态，即在编译时就以及设定好了。客户端只需要设置一个Context类的起始状态，通过调用Context类来间接执行状态方法。它更像是if-else。
职责链模式中具体子类只需要提供一个设置下一处理者的接口，不需要知道下一个处理者是谁。客户端自行串起整条链，即在运行时设定完成。它更像是switch-case。

相对比，职责链模式比状态模式更加灵活，耦合更低。而在客户端调用上职责链模式比状态模式繁琐，状态模式只需要维护一个Context类对象。
