《大话设计模式》中的示例代码和各模式练习题 以Test结尾的package为改设计模式练习题，题目在test.java中----练习题来源https://blog.csdn.net/qq_33220449/

AbstractFactory---抽象工厂模式：eg：使用不同数据库的数据访问，使用了反射+配置文件的方式实现切换数据库而不需要改动代码

Adapter---适配器模式：为了解决接口不兼容的问题，eg：Taget为用户所期待使用的接口；Adaptee为本来有的接口（需要进行适配的类）;Adapter为适配后的类;（ps不是很懂这个模式，感觉只是继承下来然后重写一下方法而已）

Builder---建造者模式：为了将一个对象的部件构造顺序和它具体各部件的实现分离开，从而达到降耦合、易扩展的目的;eg:Poduct类为最终所需要的被建造的产品;Builder接口及子类为对象各部件的实现;Director类功能是指定对象的部件构造顺序

CARP---合成/聚合复用原则（里面有桥接模式的代码）eg:一个手机里有很多的软件，每个软件又都能安装在不同品牌的手机上，这时候就应该有'手机品牌''手机软件'两个抽象类，并且手机品牌包含手机软件，它们两个是聚合关系。HandsetSoft+子类为手机的软件，HandBrand+子类为手机的品牌

ChainResponse---职责链模式：使多个用户都能处理到请求。eg:请假、加薪操作需要让经理、总监、总经理逐个审批。注意Handler类要设置下一级处理者。

Command---命令模式:将请求封装成对象，从而可用不同的请求对客户参数化；对请求排队或者记录请求日志。eg:Receiver类为请求的执行者;Command命令类让receiver执行请求（可以在执行前后进行加工）;Invoker类要求命令类执行请求。（没能get到这个模式的思想）

Composite---组合模式:使对象可以形成树形结构以表示'部分-整体'的层次，使得用户对每个对象的使用都是一样的。eg:一个公司有总公司和多个分公司，这些部分均有HR部门和财务部门，使用组合模式可以让它们形成树形结构，从结构上对代码进行复用。

decorator---装饰模式:动态的给对象添加职责。eg:一个人穿衣服的搭配可以是多样的，比较适合用装饰模式而不适合增加子类的方式。Person为需要装饰的人; Finarty可以理解为给person穿衣服的人，其余的poqiuxie、kuaku、Tshirt可以分别理解为仅穿着破球鞋的人、仅穿着垮裤的人、仅穿着T恤的人，最后客户端调用实现类似迭代或套娃的方式对Person进行装扮。

Facade---外观模式:相当于对一个系统定义一个向外开发的接口，避免客户端之间与系统交互。

Flyweight---享元模式:与组合模式目的相似，为了实现代码的复用，举个例子比如github网站，肯定不会是给每个用户都单独做一个网站、单独用一份数据库，而是通过共享模板数据库、使用ID区分的方式。eg:注意WebFactory中是使用了HashMap对需要共享的内容进行储存，共享的WebSite仅仅是通过User的不同来区分的。

IFactory---工厂方法模式:eg:计算器

Iterator---迭代器模式:各语言已经对迭代器模式进行了封装，可以直接使用。

mediator---中介者模式:各个对象的交互都集中到中介者对象进行，各个对象对其它对象的请求通过调用中介者的方法发出。弊端是中介者需要知道所有的对象。eg:USA和Iraq的通信由联合国发出。

Memento---备忘录模式:备忘录用来存储发起人的状态，管理者储存这个备忘录，客户端调用时不必知道发起人的状态细节。eg:GameRole游戏角色为发起人，RoleStateMemento为备忘录，RoleStateCaretaker为管理者。

Observer---观察者模式（发布-订阅模式）:一种一对多的依赖关系，多个观察者对象监听一个主题对象(通知者)，主题对象状态改变时会通知所有的观察者对象。eg:Subject及子类为通知者，它收集所有的观察者对象;Observer及子类为观察者，它提供一个update方法供通知者调用。

Prototype---原型模式:Java提供了Cloneable接口以供复制，使用时注意，Cloneable调用super.clone()方法是浅复制，引用类型元素仅复制引用，如果有链表需要单独对链表循环复制。

Proxy---代理模式:代理类和原类实现同一个接口，使用时代理类调用原类的方法执行，达到隐藏一个对象的目的。

simplefactory---简单工厂模式:不符合开放封闭原则，改良后有工厂方法模式和抽象工厂模式

Singleton--单例模式:分为懒汉式和饿汉式。饿汉式在声明时就创建对象，不存在线程不安全问题。

State---状态模式:有点类似职责链模式，职责链模式是传递请求，状态模式是在内部进行的不同状态下的类型切换。eg:State及子类为具体的状态，被Context维护持有，能进行当前状态的处理，读取Context的触发条件来判断是进行当前状态的处理还是调用Context切换状态;Context类维护一个当前状态,调用维护的具体状态的方法处理请求。客户端不需要有具体的状态对象，只需要实例一个Context类，设置Context的初始状态和触发状态切换的条件的变量。

strategy---策略模式:将算法的具体实现延迟到子类，Context维护具体的策略，调用策略的具体方法。客户端只需要实例Context对象传入具体的策略，策略可以很容易的更改。

TemplateMethod---模板方法模式:抽象模板类给出逻辑框架，具体的实现延迟到子类实现。个人理解:很像策略模式，只是在抽象类中把逻辑固定好，逻辑的组成延迟到子类实现。

Visitor---访问者模式:仅适用于数据结构稳定的系统，例如人只分为男人和女人。在实际开发中使用较少，没看懂这个模式。

Zpractice---与设计模式无关，学习类加载和创建机制的验证代码，和编译期常量和运行时常量的验证代码。